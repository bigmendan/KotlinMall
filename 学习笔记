区别 Application  和 Library
设置两套 AndroidManifest

ButterKnife 和 AndroidExtractors

Anko ：一个 Kotlin 扩展库
  |------- Anko Commons
  |------- Anko Layouts       一般还是使用 xml 布局
  |------- Anko SQLite         还是一般使用三方库
  |------- Anko Coroutiones   基于Kotlin协程 做了一层封装， 一般还是使用第三方协程
  配置： 引入相对应依赖包


mvp 配置 :
 新建BaseActivity 和BaseView接口，新建BaseMvpActivity 继承BaseActivity,并实现BaseView
 新建BasePresenter,并使用泛型形式引用 BaseView ,BaseMvpActivity中使用泛型引用BasePresenter

  实际应用 继承 对应的 Base ,并实现方法


RxKotlin 和 RxAndroid 配置
    |----- RxKotlin 是基于RxJava 的扩展库 ，响应式编程 ，观察者模式，订阅&监听
    |------ 也是基于RxJava 的扩展库，更好的兼容 Android 开发


转移到 Android X
  博客  ： https://www.jianshu.com/p/773e231daed4

   在 gradle.properties 文件中添加

       android.useAndroidX=true
       android.enableJetifier=true
   如果你想使用AndroidX，但是之前的不迁移，可以这样配置：

       android.useAndroidX=true
       android.enableJetifier=false



引入 Retrofit 网络框架 结合 RxJava2 的使用


引入 Dagger2 注解框架
        |
        |------- @Inject
                 @Component  注入器，连接目标类 和依赖实例的桥梁
                             以@Component标注的类必须是接口或者抽象类
                             Component 依赖关系通过dependencies 属性添加
                             App 必须有一个全局Component 用来管理全局实例;

        |------- @Module      第三方库无法修改，不能再其构造函数添加 @Inject
                              接口不能实例化，只能通过实现类实例化
                              Module 是一个简单工厂，创建类实例的方法
                              Component 通过modules 属性加入多个Module
                 @Provides    在Module中，使用@Provides 标注创建实例的方法
                              实例化流程 ：Component 搜索@Inject 注解 的属性
                                          Component 查找Module 中以@Provides 注解的对应方法，创建实例;

        |------- @Scope       @Singleton
        |------- @Qualifier   @Named





基本控件封装
  AppManager 封装
        |
        |-- 实现自己的栈结构 来管理 Activity  (单例)
  HeaderBar   封装
  ProgressLoading 封装











